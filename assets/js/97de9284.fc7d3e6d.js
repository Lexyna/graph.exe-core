"use strict";(self.webpackChunkgraph_exe=self.webpackChunkgraph_exe||[]).push([[140],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>g});var o=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function u(e,n){if(null==e)return{};var t,o,i=function(e,n){if(null==e)return{};var t,o,i={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=o.createContext({}),l=function(e){var n=o.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},d=function(e){var n=l(e.components);return o.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},p=o.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=u(e,["components","mdxType","originalType","parentName"]),p=l(t),g=i,m=p["".concat(s,".").concat(g)]||p[g]||c[g]||r;return t?o.createElement(m,a(a({ref:n},d),{},{components:t})):o.createElement(m,a({ref:n},d))}));function g(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,a=new Array(r);a[0]=p;var u={};for(var s in n)hasOwnProperty.call(n,s)&&(u[s]=n[s]);u.originalType=e,u.mdxType="string"==typeof e?e:i,a[1]=u;for(var l=2;l<r;l++)a[l]=t[l];return o.createElement.apply(null,a)}return o.createElement.apply(null,t)}p.displayName="MDXCreateElement"},9443:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>a,default:()=>c,frontMatter:()=>r,metadata:()=>u,toc:()=>l});var o=t(7462),i=(t(7294),t(3905));const r={sidebar_position:1},a="Quick Start Guide: Core",u={unversionedId:"Documentation/qsgCore",id:"Documentation/qsgCore",title:"Quick Start Guide: Core",description:"If you want to use any of the available plugins, refer to their Quick Start guide instead:",source:"@site/docs/Documentation/qsgCore.md",sourceDirName:"Documentation",slug:"/Documentation/qsgCore",permalink:"/Documentation/qsgCore",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Documentation/qsgCore.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Core",permalink:"/category/core"},next:{title:"Functions",permalink:"/Documentation/functions"}},s={},l=[{value:"Step1: Defining our IO Ports",id:"step1-defining-our-io-ports",level:2},{value:"Step2: Defining our ConfigNodes",id:"step2-defining-our-confignodes",level:2},{value:"Step3: Defining our EngineNodes",id:"step3-defining-our-enginenodes",level:2},{value:"Step4: Connecting our nodes",id:"step4-connecting-our-nodes",level:2},{value:"Step5: Executing our graph",id:"step5-executing-our-graph",level:2},{value:"Step6: Executing another node",id:"step6-executing-another-node",level:2}],d={toc:l};function c(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,o.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"quick-start-guide-core"},"Quick Start Guide: Core"),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"If you want to use any of the available plugins, refer to their Quick Start guide instead:\n",(0,i.kt)("a",{parentName:"p",href:"/React/qsgReact"},(0,i.kt)("inlineCode",{parentName:"a"},"React")),".")),(0,i.kt)("p",null,"This is step-by-step guide on how you can create any kind of graph with the help graph.exe.\nIn this guide we will create a simple graph, that does some basic addition and will then print out our result on the console."),(0,i.kt)("p",null,"To follow this tutorial make sure you install the ",(0,i.kt)("inlineCode",{parentName:"p"},"graph.exe-core")," package."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"npm install graph.exe-core\n")),(0,i.kt)("h2",{id:"step1-defining-our-io-ports"},"Step1: Defining our IO Ports"),(0,i.kt)("p",null,"The first step we have tp take in order to create our graph, is defining what kind of data we want to transport. For our simple graph, it will be enough to only have a ",(0,i.kt)("inlineCode",{parentName:"p"},"number")," type:"),(0,i.kt)("p",null,"Let's define them in a new file for our IO ports"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/io.ts"',title:'"src/io.ts"'},'//This will be out Input port\nconst numberIn: EngineIO<null, number> = {\n    type: "number",\n    mapping: CON_MAPPING.SINGLE\n    data: null,\n    value: 0\n}\n\n//This will be our Output port\nconst numberout: EngineIO<null, number> => {\n    type: "number",\n    mapping: CON_MAPPING.MULTI,\n    data: null,\n    value: 0\n}\n\n')),(0,i.kt)("h2",{id:"step2-defining-our-confignodes"},"Step2: Defining our ConfigNodes"),(0,i.kt)("p",null,"Now that we have our IO ports defined, we need to think about the kind of nodes we will need. For now it well be enough to have three kinds of nodes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("inlineCode",{parentName:"li"},"rootNode")),(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("inlineCode",{parentName:"li"},"addNode")),(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("inlineCode",{parentName:"li"},"constNode"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/configNodes.ts"',title:'"src/configNodes.ts"'},'\n//in our root node, we only want to log the result, therefor we don\'t need any additional output nodes\nconst "rootNode": ConfigNode = {\n    id: "rootNode",\n    inputs: [numberIn],\n    outputs: [],\n    exe: function(numberIn: EngineIO<null, number>): void {\n        console.log(numberIn.value);\n    }\n}\n\nconst addNode: ConfigNode = {\n    id: "addNode",\n    inputs: [numberIn, numberIn],\n    outputs: [numberOut],\n    exe: function(numberIn1: EngineIO<null, number>, numberIn2: EngineIO<null, number>, numberOut: EngineIO<null, number>): void {\n        numberOut.value = numberIn1.value + numberIn2.value;\n    }\n}\n\n//Our const node will only ever output the same value, therefor we do no need to compute this node\nconst constNode: ConfigNode = {\n    id: "constNode",\n    inputs: [],\n    outputs: [numberOut],\n    exe: function(numberIn1: EngineIO<null, number>, numberIn2: EngineIO<null, number>, numberOut: EngineIO<null, number>): void {}\n}\n\n//we alo need to register our ConfigNodes, so the graph knows which node to execute\nconst configDict: ConfigNodeDict = {\n    "rootNode": rootNode,\n    "addNode": addNode,\n    "constNode": constNode\n}\n\n')),(0,i.kt)("h2",{id:"step3-defining-our-enginenodes"},"Step3: Defining our EngineNodes"),(0,i.kt)("p",null,"Normally, if you were working with a graphical user interface, this would be step where the user itself can define their very own graph using our predefined ",(0,i.kt)("inlineCode",{parentName:"p"},"ConfigNodes"),". As we are however working without a separate gui, we will instead create a fixed graph that will compute: ",(0,i.kt)("inlineCode",{parentName:"p"},"1 + 1 = 2"),"."),(0,i.kt)("p",null,"First, we need to create exactly one ",(0,i.kt)("inlineCode",{parentName:"p"},"EngineNode")," for each of our ",(0,i.kt)("inlineCode",{parentName:"p"},"ConfigNodes"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/index.ts"',title:'"src/index.ts"'},'const myConst1Node: EngineNode = nodeBuilder(constNode, "myConstNode1Id");\n\nmyConst1Node.output[0].value = 1; // we need to set out output value for this node specifically as the default value is 0.\n\nconst myAddNode: EngineNode = nodeBuilder(addNode, "myAddNode");\nconst myRootNode: EngineNode = nodeBuilder(rootNode, "root"); \n')),(0,i.kt)("p",null,"second, we need to register them so our graph know which EngineNodes to work with:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/index.ts"',title:'"src/index.ts"'},'const nodes: EngineNodeDict = {\n    "myConstNode1Id": myConst1Node,\n    "myAddNode": myAddNode,\n    "root": myRootNode\n}\n')),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Note how we had to set the output value for our const node explicitly in the code. Normally you would either have to create a ",(0,i.kt)("inlineCode",{parentName:"p"},"ConfigNode")," with each of the desired output values, or create a dynamic const node like shown in the ",(0,i.kt)("a",{parentName:"p",href:"/React/qsgReact"},(0,i.kt)("inlineCode",{parentName:"a"},"react quick start guide")),".")),(0,i.kt)("h2",{id:"step4-connecting-our-nodes"},"Step4: Connecting our nodes"),(0,i.kt)("p",null,"Connecting our nodes is simple with the help of the ",(0,i.kt)("inlineCode",{parentName:"p"},"connector")," function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/index.ts"',title:'"src/index.ts"'},"\n//first we need to create a new connectionDict\n\nconst connectionDict: Engineconnections = {\n    input: {},\n    output: {}\n}\n\n//now we need to extract our connections\n\nconst myConst1NodeConDetails: NodePorts = extractor(myConst1Node);\nconst myAddNodeConDetails: NodePorts = extractor(myAddNode);\nconst myRootNodeConDetails: NodePorts = extractor(myRootNode);\n\n//And finally we can connect our nodes to each other\n\n//Connect our const1Node to the first input of our addNode\nconnector(myConst1NodeConDetails.outputs[0], myAddNodeConDetails.inputs[0], connectionDict);\n\n//Connect our const1Node to the second input of our addNode\nconnector(myConst1NodeConDetails.outputs[1], myAddNodeConDetails.inputs[0], connectionDict);\n\n//Connect our addNode output to the input of our rootNode\nconnector(myAddNodeConDetails.outputs[0], myRootNodeConDetails.inputs[0], connectionDict);\n")),(0,i.kt)("h2",{id:"step5-executing-our-graph"},"Step5: Executing our graph"),(0,i.kt)("p",null,"Finally, all we need to do now if call the execution function with all predefined parameters:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/index.ts"',title:'"src/index.ts"'},'executeGraph(configDict, nodes, connectionDict, "root");\n')),(0,i.kt)("p",null,"Output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"2\n")),(0,i.kt)("h2",{id:"step6-executing-another-node"},"Step6: Executing another node"),(0,i.kt)("p",null,"Now that we have out graph computing our output, let's create a new node which will take a input and log it to our console instead of having our root node do it. "),(0,i.kt)("p",null,"First, let's add two new ",(0,i.kt)("a",{parentName:"p",href:"/Documentation/connectionTypes#engineio"},(0,i.kt)("inlineCode",{parentName:"a"},"EngineIO")),"'s to process our forward signals:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/io.ts"',title:'"src/io.ts"'},'\n...\n\n//As we won\'t be passing any data on those node ports, we can assign them <null, null> for data and value \nconst  signalIn: EngineIO<null, null>: EngineIO = {\n    type: "signal",\n    mapping: CON_MAPPING.SINGLE,\n    data: null,\n    value: null\n}\n\n//To make the graph a little simpler, let\'s define that each node should only have one other node it can trigger\nconst signalOut: EngineIO<null, null>: EngineIO ?> {\n    type: "signal",\n    mapping: CON_MAPPING.SINGLE,\n    data: null,\n    value: null\n}\n\n')),(0,i.kt)("p",null,"Now, let's slightly adjust our node to output our value and trigger another node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/configNodes.ts"',title:'"src/configNodes.ts"'},'const "rootNode": ConfigNode = {\n    id: "rootNode",\n    inputs: [numberIn],\n    outputs: [signalOut, numberOut],\n    exe: function(numberIn: EngineIO<null, number>, signalOut: EngineIO<null, null>, numberOut: EngineIO<null, number>): void {\n        numberOut.value = numberIn.value;\n        next(signalOut);\n    }\n}\n')),(0,i.kt)("p",null,"We also need to define our new log node like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/configNodes.ts"',title:'"src/configNodes.ts"'},'const logNode: ConfigNode = {\n    id: "logNode",\n    inputs: [signalIn, numberIn],\n    outputs: [],\n    exe: function(signalIn: EngineIO<null, null>, numberIn: EngineIO<null, number>): void {\n        console.log(numberIn.value);\n    }\n}\n\n//Don\'t forget to add it to our config!\nconst configDict: ConfigNodeDict = {\n    "rootNode": rootNode,\n    "addNode": addNode,\n    "constNode": constNode,\n    // highlight-next-line\n    "logNode": logNode\n}\n\n')),(0,i.kt)("p",null,"Now we create a new instance of our logNode and add it to out dict:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/index.ts"',title:'"src/index.ts"'},'const myLogNode: EngineNode = nodeBuilder(logNode, "myLogNode");\n\nconst nodes: EngineNodeDict = {\n    "myConstNode1Id": myConst1Node,\n    "myAddNode": myAddNode,\n    "root": myRootNode,\n    // highlight-next-line\n    "myLogNode": myLogNode\n}\n')),(0,i.kt)("p",null,"All we have to do next is connect our new ",(0,i.kt)("a",{parentName:"p",href:"/Documentation/NodeTypes#enginenode"},(0,i.kt)("inlineCode",{parentName:"a"},"EngineNode"))," with our modified root node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/index.ts"',title:'"src/index.ts"'},"const connectionDict: Engineconnections = {\n    input: {},\n    output: {}\n}\n\n//now we need to extract our connections\n\nconst myConst1NodeConDetails: NodePorts = extractor(myConst1Node);\nconst myAddNodeConDetails: NodePorts = extractor(myAddNode);\nconst myRootNodeConDetails: NodePorts = extractor(myRootNode);\n// highlight-next-line\nconst myLogNodeConDetails: NodePorts = extractor(myLogNode);\n\n//And finally we can connect our nodes to each other\n\n//Connect our const1Node to the first input of our addNode\nconnector(myConst1NodeConDetails.outputs[0], myAddNodeConDetails.inputs[0], connectionDict);\n\n//Connect our const1Node to the second input of our addNode\nconnector(myConst1NodeConDetails.outputs[1], myAddNodeConDetails.inputs[0], connectionDict);\n\n//Connect our addNode output to the input of our rootNode\nconnector(myAddNodeConDetails.outputs[0], myRootNodeConDetails.inputs[0], connectionDict);\n\n// highlight-start\n//This connects our root nodes 'signalOut' with our logNode's 'signalIn'\nconnector(myRootNodeConDetails.outputs[0], myLogNodeConDetails.inputs[0], connectionDict);\n//This connects our rootNode's 'numberOut' with out logNode's 'numberIn'\nconnector(myRootNodeConDetails.outputs[1], myLogNodeConDetails.inputs[1], connectionDict);\n// highlight-end\n")),(0,i.kt)("p",null,"All that's left to do now is executing our modified graph again:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/index.ts"',title:'"src/index.ts"'},'executeGraph(configDict, nodes, connectionDict, "root");\n')),(0,i.kt)("p",null,"And if everything was set up correctly we should get our output again:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"2\n")))}c.isMDXComponent=!0}}]);